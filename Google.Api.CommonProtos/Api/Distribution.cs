/*
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file or at
 * https://developers.google.com/open-source/licenses/bsd
 */

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/api/distribution.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Api {

  /// <summary>Holder for reflection information generated from google/api/distribution.proto</summary>
  public static partial class DistributionReflection {

    #region Descriptor
    /// <summary>File descriptor for google/api/distribution.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DistributionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch1nb29nbGUvYXBpL2Rpc3RyaWJ1dGlvbi5wcm90bxIKZ29vZ2xlLmFwaRoZ",
            "Z29vZ2xlL3Byb3RvYnVmL2FueS5wcm90bxofZ29vZ2xlL3Byb3RvYnVmL3Rp",
            "bWVzdGFtcC5wcm90byLZBgoMRGlzdHJpYnV0aW9uEg0KBWNvdW50GAEgASgD",
            "EgwKBG1lYW4YAiABKAESIAoYc3VtX29mX3NxdWFyZWRfZGV2aWF0aW9uGAMg",
            "ASgBEi0KBXJhbmdlGAQgASgLMh4uZ29vZ2xlLmFwaS5EaXN0cmlidXRpb24u",
            "UmFuZ2USPgoOYnVja2V0X29wdGlvbnMYBiABKAsyJi5nb29nbGUuYXBpLkRp",
            "c3RyaWJ1dGlvbi5CdWNrZXRPcHRpb25zEhUKDWJ1Y2tldF9jb3VudHMYByAD",
            "KAMSNAoJZXhlbXBsYXJzGAogAygLMiEuZ29vZ2xlLmFwaS5EaXN0cmlidXRp",
            "b24uRXhlbXBsYXIaIQoFUmFuZ2USCwoDbWluGAEgASgBEgsKA21heBgCIAEo",
            "ARq1AwoNQnVja2V0T3B0aW9ucxJHCg5saW5lYXJfYnVja2V0cxgBIAEoCzIt",
            "Lmdvb2dsZS5hcGkuRGlzdHJpYnV0aW9uLkJ1Y2tldE9wdGlvbnMuTGluZWFy",
            "SAASUQoTZXhwb25lbnRpYWxfYnVja2V0cxgCIAEoCzIyLmdvb2dsZS5hcGku",
            "RGlzdHJpYnV0aW9uLkJ1Y2tldE9wdGlvbnMuRXhwb25lbnRpYWxIABJLChBl",
            "eHBsaWNpdF9idWNrZXRzGAMgASgLMi8uZ29vZ2xlLmFwaS5EaXN0cmlidXRp",
            "b24uQnVja2V0T3B0aW9ucy5FeHBsaWNpdEgAGkMKBkxpbmVhchIaChJudW1f",
            "ZmluaXRlX2J1Y2tldHMYASABKAUSDQoFd2lkdGgYAiABKAESDgoGb2Zmc2V0",
            "GAMgASgBGk8KC0V4cG9uZW50aWFsEhoKEm51bV9maW5pdGVfYnVja2V0cxgB",
            "IAEoBRIVCg1ncm93dGhfZmFjdG9yGAIgASgBEg0KBXNjYWxlGAMgASgBGhoK",
            "CEV4cGxpY2l0Eg4KBmJvdW5kcxgBIAMoAUIJCgdvcHRpb25zGnMKCEV4ZW1w",
            "bGFyEg0KBXZhbHVlGAEgASgBEi0KCXRpbWVzdGFtcBgCIAEoCzIaLmdvb2ds",
            "ZS5wcm90b2J1Zi5UaW1lc3RhbXASKQoLYXR0YWNobWVudHMYAyADKAsyFC5n",
            "b29nbGUucHJvdG9idWYuQW55QnEKDmNvbS5nb29nbGUuYXBpQhFEaXN0cmli",
            "dXRpb25Qcm90b1ABWkNnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29n",
            "bGVhcGlzL2FwaS9kaXN0cmlidXRpb247ZGlzdHJpYnV0aW9uogIER0FQSWIG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution), global::Google.Api.Distribution.Parser, new[]{ "Count", "Mean", "SumOfSquaredDeviation", "Range", "BucketOptions", "BucketCounts", "Exemplars" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.Range), global::Google.Api.Distribution.Types.Range.Parser, new[]{ "Min", "Max" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.BucketOptions), global::Google.Api.Distribution.Types.BucketOptions.Parser, new[]{ "LinearBuckets", "ExponentialBuckets", "ExplicitBuckets" }, new[]{ "Options" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.BucketOptions.Types.Linear), global::Google.Api.Distribution.Types.BucketOptions.Types.Linear.Parser, new[]{ "NumFiniteBuckets", "Width", "Offset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential), global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential.Parser, new[]{ "NumFiniteBuckets", "GrowthFactor", "Scale" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit), global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit.Parser, new[]{ "Bounds" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Distribution.Types.Exemplar), global::Google.Api.Distribution.Types.Exemplar.Parser, new[]{ "Value", "Timestamp", "Attachments" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// `Distribution` contains summary statistics for a population of values. It
  /// optionally contains a histogram representing the distribution of those values
  /// across a set of buckets.
  ///
  /// The summary statistics are the count, mean, sum of the squared deviation from
  /// the mean, the minimum, and the maximum of the set of population of values.
  /// The histogram is based on a sequence of buckets and gives a count of values
  /// that fall into each bucket. The boundaries of the buckets are given either
  /// explicitly or by formulas for buckets of fixed or exponentially increasing
  /// widths.
  ///
  /// Although it is not forbidden, it is generally a bad idea to include
  /// non-finite values (infinities or NaNs) in the population of values, as this
  /// will render the `mean` and `sum_of_squared_deviation` fields meaningless.
  /// </summary>
  public sealed partial class Distribution : pb::IMessage<Distribution> {
    private static readonly pb::MessageParser<Distribution> _parser = new pb::MessageParser<Distribution>(() => new Distribution());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Distribution> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Api.DistributionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Distribution() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Distribution(Distribution other) : this() {
      count_ = other.count_;
      mean_ = other.mean_;
      sumOfSquaredDeviation_ = other.sumOfSquaredDeviation_;
      range_ = other.range_ != null ? other.range_.Clone() : null;
      bucketOptions_ = other.bucketOptions_ != null ? other.bucketOptions_.Clone() : null;
      bucketCounts_ = other.bucketCounts_.Clone();
      exemplars_ = other.exemplars_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Distribution Clone() {
      return new Distribution(this);
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 1;
    private long count_;
    /// <summary>
    /// The number of values in the population. Must be non-negative. This value
    /// must equal the sum of the values in `bucket_counts` if a histogram is
    /// provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "mean" field.</summary>
    public const int MeanFieldNumber = 2;
    private double mean_;
    /// <summary>
    /// The arithmetic mean of the values in the population. If `count` is zero
    /// then this field must be zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Mean {
      get { return mean_; }
      set {
        mean_ = value;
      }
    }

    /// <summary>Field number for the "sum_of_squared_deviation" field.</summary>
    public const int SumOfSquaredDeviationFieldNumber = 3;
    private double sumOfSquaredDeviation_;
    /// <summary>
    /// The sum of squared deviations from the mean of the values in the
    /// population. For values x_i this is:
    ///
    ///     Sum[i=1..n]((x_i - mean)^2)
    ///
    /// Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
    /// describes Welford's method for accumulating this sum in one pass.
    ///
    /// If `count` is zero then this field must be zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double SumOfSquaredDeviation {
      get { return sumOfSquaredDeviation_; }
      set {
        sumOfSquaredDeviation_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 4;
    private global::Google.Api.Distribution.Types.Range range_;
    /// <summary>
    /// If specified, contains the range of the population values. The field
    /// must not be present if the `count` is zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.Distribution.Types.Range Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    /// <summary>Field number for the "bucket_options" field.</summary>
    public const int BucketOptionsFieldNumber = 6;
    private global::Google.Api.Distribution.Types.BucketOptions bucketOptions_;
    /// <summary>
    /// Defines the histogram bucket boundaries. If the distribution does not
    /// contain a histogram, then omit this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.Distribution.Types.BucketOptions BucketOptions {
      get { return bucketOptions_; }
      set {
        bucketOptions_ = value;
      }
    }

    /// <summary>Field number for the "bucket_counts" field.</summary>
    public const int BucketCountsFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_bucketCounts_codec
        = pb::FieldCodec.ForInt64(58);
    private readonly pbc::RepeatedField<long> bucketCounts_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The number of values in each bucket of the histogram, as described in
    /// `bucket_options`. If the distribution does not have a histogram, then omit
    /// this field. If there is a histogram, then the sum of the values in
    /// `bucket_counts` must equal the value in the `count` field of the
    /// distribution.
    ///
    /// If present, `bucket_counts` should contain N values, where N is the number
    /// of buckets specified in `bucket_options`. If you supply fewer than N
    /// values, the remaining values are assumed to be 0.
    ///
    /// The order of the values in `bucket_counts` follows the bucket numbering
    /// schemes described for the three bucket types. The first value must be the
    /// count for the underflow bucket (number 0). The next N-2 values are the
    /// counts for the finite buckets (number 1 through N-2). The N'th value in
    /// `bucket_counts` is the count for the overflow bucket (number N-1).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> BucketCounts {
      get { return bucketCounts_; }
    }

    /// <summary>Field number for the "exemplars" field.</summary>
    public const int ExemplarsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Api.Distribution.Types.Exemplar> _repeated_exemplars_codec
        = pb::FieldCodec.ForMessage(82, global::Google.Api.Distribution.Types.Exemplar.Parser);
    private readonly pbc::RepeatedField<global::Google.Api.Distribution.Types.Exemplar> exemplars_ = new pbc::RepeatedField<global::Google.Api.Distribution.Types.Exemplar>();
    /// <summary>
    /// Must be in increasing order of `value` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Api.Distribution.Types.Exemplar> Exemplars {
      get { return exemplars_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Distribution);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Distribution other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Count != other.Count) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Mean, other.Mean)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SumOfSquaredDeviation, other.SumOfSquaredDeviation)) return false;
      if (!object.Equals(Range, other.Range)) return false;
      if (!object.Equals(BucketOptions, other.BucketOptions)) return false;
      if(!bucketCounts_.Equals(other.bucketCounts_)) return false;
      if(!exemplars_.Equals(other.exemplars_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Count != 0L) hash ^= Count.GetHashCode();
      if (Mean != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Mean);
      if (SumOfSquaredDeviation != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SumOfSquaredDeviation);
      if (range_ != null) hash ^= Range.GetHashCode();
      if (bucketOptions_ != null) hash ^= BucketOptions.GetHashCode();
      hash ^= bucketCounts_.GetHashCode();
      hash ^= exemplars_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Count != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Count);
      }
      if (Mean != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(Mean);
      }
      if (SumOfSquaredDeviation != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(SumOfSquaredDeviation);
      }
      if (range_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Range);
      }
      if (bucketOptions_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(BucketOptions);
      }
      bucketCounts_.WriteTo(output, _repeated_bucketCounts_codec);
      exemplars_.WriteTo(output, _repeated_exemplars_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Count != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Count);
      }
      if (Mean != 0D) {
        size += 1 + 8;
      }
      if (SumOfSquaredDeviation != 0D) {
        size += 1 + 8;
      }
      if (range_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Range);
      }
      if (bucketOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BucketOptions);
      }
      size += bucketCounts_.CalculateSize(_repeated_bucketCounts_codec);
      size += exemplars_.CalculateSize(_repeated_exemplars_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Distribution other) {
      if (other == null) {
        return;
      }
      if (other.Count != 0L) {
        Count = other.Count;
      }
      if (other.Mean != 0D) {
        Mean = other.Mean;
      }
      if (other.SumOfSquaredDeviation != 0D) {
        SumOfSquaredDeviation = other.SumOfSquaredDeviation;
      }
      if (other.range_ != null) {
        if (range_ == null) {
          Range = new global::Google.Api.Distribution.Types.Range();
        }
        Range.MergeFrom(other.Range);
      }
      if (other.bucketOptions_ != null) {
        if (bucketOptions_ == null) {
          BucketOptions = new global::Google.Api.Distribution.Types.BucketOptions();
        }
        BucketOptions.MergeFrom(other.BucketOptions);
      }
      bucketCounts_.Add(other.bucketCounts_);
      exemplars_.Add(other.exemplars_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Count = input.ReadInt64();
            break;
          }
          case 17: {
            Mean = input.ReadDouble();
            break;
          }
          case 25: {
            SumOfSquaredDeviation = input.ReadDouble();
            break;
          }
          case 34: {
            if (range_ == null) {
              Range = new global::Google.Api.Distribution.Types.Range();
            }
            input.ReadMessage(Range);
            break;
          }
          case 50: {
            if (bucketOptions_ == null) {
              BucketOptions = new global::Google.Api.Distribution.Types.BucketOptions();
            }
            input.ReadMessage(BucketOptions);
            break;
          }
          case 58:
          case 56: {
            bucketCounts_.AddEntriesFrom(input, _repeated_bucketCounts_codec);
            break;
          }
          case 82: {
            exemplars_.AddEntriesFrom(input, _repeated_exemplars_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Distribution message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The range of the population values.
      /// </summary>
      public sealed partial class Range : pb::IMessage<Range> {
        private static readonly pb::MessageParser<Range> _parser = new pb::MessageParser<Range>(() => new Range());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Range> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Api.Distribution.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Range() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Range(Range other) : this() {
          min_ = other.min_;
          max_ = other.max_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Range Clone() {
          return new Range(this);
        }

        /// <summary>Field number for the "min" field.</summary>
        public const int MinFieldNumber = 1;
        private double min_;
        /// <summary>
        /// The minimum of the population values.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Min {
          get { return min_; }
          set {
            min_ = value;
          }
        }

        /// <summary>Field number for the "max" field.</summary>
        public const int MaxFieldNumber = 2;
        private double max_;
        /// <summary>
        /// The maximum of the population values.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Max {
          get { return max_; }
          set {
            max_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Range);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Range other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Min, other.Min)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Max, other.Max)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Min != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Min);
          if (Max != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Max);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Min != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Min);
          }
          if (Max != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Max);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Min != 0D) {
            size += 1 + 8;
          }
          if (Max != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Range other) {
          if (other == null) {
            return;
          }
          if (other.Min != 0D) {
            Min = other.Min;
          }
          if (other.Max != 0D) {
            Max = other.Max;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                Min = input.ReadDouble();
                break;
              }
              case 17: {
                Max = input.ReadDouble();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// `BucketOptions` describes the bucket boundaries used to create a histogram
      /// for the distribution. The buckets can be in a linear sequence, an
      /// exponential sequence, or each bucket can be specified explicitly.
      /// `BucketOptions` does not include the number of values in each bucket.
      ///
      /// A bucket has an inclusive lower bound and exclusive upper bound for the
      /// values that are counted for that bucket. The upper bound of a bucket must
      /// be strictly greater than the lower bound. The sequence of N buckets for a
      /// distribution consists of an underflow bucket (number 0), zero or more
      /// finite buckets (number 1 through N - 2) and an overflow bucket (number N -
      /// 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
      /// same as the upper bound of bucket i - 1. The buckets span the whole range
      /// of finite values: lower bound of the underflow bucket is -infinity and the
      /// upper bound of the overflow bucket is +infinity. The finite buckets are
      /// so-called because both bounds are finite.
      /// </summary>
      public sealed partial class BucketOptions : pb::IMessage<BucketOptions> {
        private static readonly pb::MessageParser<BucketOptions> _parser = new pb::MessageParser<BucketOptions>(() => new BucketOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BucketOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Api.Distribution.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BucketOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BucketOptions(BucketOptions other) : this() {
          switch (other.OptionsCase) {
            case OptionsOneofCase.LinearBuckets:
              LinearBuckets = other.LinearBuckets.Clone();
              break;
            case OptionsOneofCase.ExponentialBuckets:
              ExponentialBuckets = other.ExponentialBuckets.Clone();
              break;
            case OptionsOneofCase.ExplicitBuckets:
              ExplicitBuckets = other.ExplicitBuckets.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BucketOptions Clone() {
          return new BucketOptions(this);
        }

        /// <summary>Field number for the "linear_buckets" field.</summary>
        public const int LinearBucketsFieldNumber = 1;
        /// <summary>
        /// The linear bucket.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Api.Distribution.Types.BucketOptions.Types.Linear LinearBuckets {
          get { return optionsCase_ == OptionsOneofCase.LinearBuckets ? (global::Google.Api.Distribution.Types.BucketOptions.Types.Linear) options_ : null; }
          set {
            options_ = value;
            optionsCase_ = value == null ? OptionsOneofCase.None : OptionsOneofCase.LinearBuckets;
          }
        }

        /// <summary>Field number for the "exponential_buckets" field.</summary>
        public const int ExponentialBucketsFieldNumber = 2;
        /// <summary>
        /// The exponential buckets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential ExponentialBuckets {
          get { return optionsCase_ == OptionsOneofCase.ExponentialBuckets ? (global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential) options_ : null; }
          set {
            options_ = value;
            optionsCase_ = value == null ? OptionsOneofCase.None : OptionsOneofCase.ExponentialBuckets;
          }
        }

        /// <summary>Field number for the "explicit_buckets" field.</summary>
        public const int ExplicitBucketsFieldNumber = 3;
        /// <summary>
        /// The explicit buckets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit ExplicitBuckets {
          get { return optionsCase_ == OptionsOneofCase.ExplicitBuckets ? (global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit) options_ : null; }
          set {
            options_ = value;
            optionsCase_ = value == null ? OptionsOneofCase.None : OptionsOneofCase.ExplicitBuckets;
          }
        }

        private object options_;
        /// <summary>Enum of possible cases for the "options" oneof.</summary>
        public enum OptionsOneofCase {
          None = 0,
          LinearBuckets = 1,
          ExponentialBuckets = 2,
          ExplicitBuckets = 3,
        }
        private OptionsOneofCase optionsCase_ = OptionsOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OptionsOneofCase OptionsCase {
          get { return optionsCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearOptions() {
          optionsCase_ = OptionsOneofCase.None;
          options_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BucketOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BucketOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(LinearBuckets, other.LinearBuckets)) return false;
          if (!object.Equals(ExponentialBuckets, other.ExponentialBuckets)) return false;
          if (!object.Equals(ExplicitBuckets, other.ExplicitBuckets)) return false;
          if (OptionsCase != other.OptionsCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (optionsCase_ == OptionsOneofCase.LinearBuckets) hash ^= LinearBuckets.GetHashCode();
          if (optionsCase_ == OptionsOneofCase.ExponentialBuckets) hash ^= ExponentialBuckets.GetHashCode();
          if (optionsCase_ == OptionsOneofCase.ExplicitBuckets) hash ^= ExplicitBuckets.GetHashCode();
          hash ^= (int) optionsCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (optionsCase_ == OptionsOneofCase.LinearBuckets) {
            output.WriteRawTag(10);
            output.WriteMessage(LinearBuckets);
          }
          if (optionsCase_ == OptionsOneofCase.ExponentialBuckets) {
            output.WriteRawTag(18);
            output.WriteMessage(ExponentialBuckets);
          }
          if (optionsCase_ == OptionsOneofCase.ExplicitBuckets) {
            output.WriteRawTag(26);
            output.WriteMessage(ExplicitBuckets);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (optionsCase_ == OptionsOneofCase.LinearBuckets) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinearBuckets);
          }
          if (optionsCase_ == OptionsOneofCase.ExponentialBuckets) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExponentialBuckets);
          }
          if (optionsCase_ == OptionsOneofCase.ExplicitBuckets) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExplicitBuckets);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BucketOptions other) {
          if (other == null) {
            return;
          }
          switch (other.OptionsCase) {
            case OptionsOneofCase.LinearBuckets:
              if (LinearBuckets == null) {
                LinearBuckets = new global::Google.Api.Distribution.Types.BucketOptions.Types.Linear();
              }
              LinearBuckets.MergeFrom(other.LinearBuckets);
              break;
            case OptionsOneofCase.ExponentialBuckets:
              if (ExponentialBuckets == null) {
                ExponentialBuckets = new global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential();
              }
              ExponentialBuckets.MergeFrom(other.ExponentialBuckets);
              break;
            case OptionsOneofCase.ExplicitBuckets:
              if (ExplicitBuckets == null) {
                ExplicitBuckets = new global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit();
              }
              ExplicitBuckets.MergeFrom(other.ExplicitBuckets);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Api.Distribution.Types.BucketOptions.Types.Linear subBuilder = new global::Google.Api.Distribution.Types.BucketOptions.Types.Linear();
                if (optionsCase_ == OptionsOneofCase.LinearBuckets) {
                  subBuilder.MergeFrom(LinearBuckets);
                }
                input.ReadMessage(subBuilder);
                LinearBuckets = subBuilder;
                break;
              }
              case 18: {
                global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential subBuilder = new global::Google.Api.Distribution.Types.BucketOptions.Types.Exponential();
                if (optionsCase_ == OptionsOneofCase.ExponentialBuckets) {
                  subBuilder.MergeFrom(ExponentialBuckets);
                }
                input.ReadMessage(subBuilder);
                ExponentialBuckets = subBuilder;
                break;
              }
              case 26: {
                global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit subBuilder = new global::Google.Api.Distribution.Types.BucketOptions.Types.Explicit();
                if (optionsCase_ == OptionsOneofCase.ExplicitBuckets) {
                  subBuilder.MergeFrom(ExplicitBuckets);
                }
                input.ReadMessage(subBuilder);
                ExplicitBuckets = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the BucketOptions message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Specifies a linear sequence of buckets that all have the same width
          /// (except overflow and underflow). Each bucket represents a constant
          /// absolute uncertainty on the specific value in the bucket.
          ///
          /// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
          /// following boundaries:
          ///
          ///    Upper bound (0 &lt;= i &lt; N-1):     offset + (width * i).
          ///    Lower bound (1 &lt;= i &lt; N):       offset + (width * (i - 1)).
          /// </summary>
          public sealed partial class Linear : pb::IMessage<Linear> {
            private static readonly pb::MessageParser<Linear> _parser = new pb::MessageParser<Linear>(() => new Linear());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Linear> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Api.Distribution.Types.BucketOptions.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Linear() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Linear(Linear other) : this() {
              numFiniteBuckets_ = other.numFiniteBuckets_;
              width_ = other.width_;
              offset_ = other.offset_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Linear Clone() {
              return new Linear(this);
            }

            /// <summary>Field number for the "num_finite_buckets" field.</summary>
            public const int NumFiniteBucketsFieldNumber = 1;
            private int numFiniteBuckets_;
            /// <summary>
            /// Must be greater than 0.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int NumFiniteBuckets {
              get { return numFiniteBuckets_; }
              set {
                numFiniteBuckets_ = value;
              }
            }

            /// <summary>Field number for the "width" field.</summary>
            public const int WidthFieldNumber = 2;
            private double width_;
            /// <summary>
            /// Must be greater than 0.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double Width {
              get { return width_; }
              set {
                width_ = value;
              }
            }

            /// <summary>Field number for the "offset" field.</summary>
            public const int OffsetFieldNumber = 3;
            private double offset_;
            /// <summary>
            /// Lower bound of the first bucket.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double Offset {
              get { return offset_; }
              set {
                offset_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Linear);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Linear other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (NumFiniteBuckets != other.NumFiniteBuckets) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Width, other.Width)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Offset, other.Offset)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (NumFiniteBuckets != 0) hash ^= NumFiniteBuckets.GetHashCode();
              if (Width != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Width);
              if (Offset != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Offset);
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (NumFiniteBuckets != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(NumFiniteBuckets);
              }
              if (Width != 0D) {
                output.WriteRawTag(17);
                output.WriteDouble(Width);
              }
              if (Offset != 0D) {
                output.WriteRawTag(25);
                output.WriteDouble(Offset);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (NumFiniteBuckets != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumFiniteBuckets);
              }
              if (Width != 0D) {
                size += 1 + 8;
              }
              if (Offset != 0D) {
                size += 1 + 8;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Linear other) {
              if (other == null) {
                return;
              }
              if (other.NumFiniteBuckets != 0) {
                NumFiniteBuckets = other.NumFiniteBuckets;
              }
              if (other.Width != 0D) {
                Width = other.Width;
              }
              if (other.Offset != 0D) {
                Offset = other.Offset;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    NumFiniteBuckets = input.ReadInt32();
                    break;
                  }
                  case 17: {
                    Width = input.ReadDouble();
                    break;
                  }
                  case 25: {
                    Offset = input.ReadDouble();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Specifies an exponential sequence of buckets that have a width that is
          /// proportional to the value of the lower bound. Each bucket represents a
          /// constant relative uncertainty on a specific value in the bucket.
          ///
          /// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
          /// following boundaries:
          ///
          ///    Upper bound (0 &lt;= i &lt; N-1):     scale * (growth_factor ^ i).
          ///    Lower bound (1 &lt;= i &lt; N):       scale * (growth_factor ^ (i - 1)).
          /// </summary>
          public sealed partial class Exponential : pb::IMessage<Exponential> {
            private static readonly pb::MessageParser<Exponential> _parser = new pb::MessageParser<Exponential>(() => new Exponential());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Exponential> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Api.Distribution.Types.BucketOptions.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Exponential() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Exponential(Exponential other) : this() {
              numFiniteBuckets_ = other.numFiniteBuckets_;
              growthFactor_ = other.growthFactor_;
              scale_ = other.scale_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Exponential Clone() {
              return new Exponential(this);
            }

            /// <summary>Field number for the "num_finite_buckets" field.</summary>
            public const int NumFiniteBucketsFieldNumber = 1;
            private int numFiniteBuckets_;
            /// <summary>
            /// Must be greater than 0.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int NumFiniteBuckets {
              get { return numFiniteBuckets_; }
              set {
                numFiniteBuckets_ = value;
              }
            }

            /// <summary>Field number for the "growth_factor" field.</summary>
            public const int GrowthFactorFieldNumber = 2;
            private double growthFactor_;
            /// <summary>
            /// Must be greater than 1.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double GrowthFactor {
              get { return growthFactor_; }
              set {
                growthFactor_ = value;
              }
            }

            /// <summary>Field number for the "scale" field.</summary>
            public const int ScaleFieldNumber = 3;
            private double scale_;
            /// <summary>
            /// Must be greater than 0.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double Scale {
              get { return scale_; }
              set {
                scale_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Exponential);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Exponential other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (NumFiniteBuckets != other.NumFiniteBuckets) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(GrowthFactor, other.GrowthFactor)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Scale, other.Scale)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (NumFiniteBuckets != 0) hash ^= NumFiniteBuckets.GetHashCode();
              if (GrowthFactor != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(GrowthFactor);
              if (Scale != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Scale);
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (NumFiniteBuckets != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(NumFiniteBuckets);
              }
              if (GrowthFactor != 0D) {
                output.WriteRawTag(17);
                output.WriteDouble(GrowthFactor);
              }
              if (Scale != 0D) {
                output.WriteRawTag(25);
                output.WriteDouble(Scale);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (NumFiniteBuckets != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumFiniteBuckets);
              }
              if (GrowthFactor != 0D) {
                size += 1 + 8;
              }
              if (Scale != 0D) {
                size += 1 + 8;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Exponential other) {
              if (other == null) {
                return;
              }
              if (other.NumFiniteBuckets != 0) {
                NumFiniteBuckets = other.NumFiniteBuckets;
              }
              if (other.GrowthFactor != 0D) {
                GrowthFactor = other.GrowthFactor;
              }
              if (other.Scale != 0D) {
                Scale = other.Scale;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    NumFiniteBuckets = input.ReadInt32();
                    break;
                  }
                  case 17: {
                    GrowthFactor = input.ReadDouble();
                    break;
                  }
                  case 25: {
                    Scale = input.ReadDouble();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Specifies a set of buckets with arbitrary widths.
          ///
          /// There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
          /// boundaries:
          ///
          ///    Upper bound (0 &lt;= i &lt; N-1):     bounds[i]
          ///    Lower bound (1 &lt;= i &lt; N);       bounds[i - 1]
          ///
          /// The `bounds` field must contain at least one element. If `bounds` has
          /// only one element, then there are no finite buckets, and that single
          /// element is the common boundary of the overflow and underflow buckets.
          /// </summary>
          public sealed partial class Explicit : pb::IMessage<Explicit> {
            private static readonly pb::MessageParser<Explicit> _parser = new pb::MessageParser<Explicit>(() => new Explicit());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Explicit> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Api.Distribution.Types.BucketOptions.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Explicit() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Explicit(Explicit other) : this() {
              bounds_ = other.bounds_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Explicit Clone() {
              return new Explicit(this);
            }

            /// <summary>Field number for the "bounds" field.</summary>
            public const int BoundsFieldNumber = 1;
            private static readonly pb::FieldCodec<double> _repeated_bounds_codec
                = pb::FieldCodec.ForDouble(10);
            private readonly pbc::RepeatedField<double> bounds_ = new pbc::RepeatedField<double>();
            /// <summary>
            /// The values must be monotonically increasing.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<double> Bounds {
              get { return bounds_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Explicit);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Explicit other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!bounds_.Equals(other.bounds_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= bounds_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              bounds_.WriteTo(output, _repeated_bounds_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += bounds_.CalculateSize(_repeated_bounds_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Explicit other) {
              if (other == null) {
                return;
              }
              bounds_.Add(other.bounds_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10:
                  case 9: {
                    bounds_.AddEntriesFrom(input, _repeated_bounds_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Exemplars are example points that may be used to annotate aggregated
      /// distribution values. They are metadata that gives information about a
      /// particular value added to a Distribution bucket, such as a trace ID that
      /// was active when a value was added. They may contain further information,
      /// such as a example values and timestamps, origin, etc.
      /// </summary>
      public sealed partial class Exemplar : pb::IMessage<Exemplar> {
        private static readonly pb::MessageParser<Exemplar> _parser = new pb::MessageParser<Exemplar>(() => new Exemplar());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Exemplar> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Api.Distribution.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Exemplar() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Exemplar(Exemplar other) : this() {
          value_ = other.value_;
          timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
          attachments_ = other.attachments_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Exemplar Clone() {
          return new Exemplar(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private double value_;
        /// <summary>
        /// Value of the exemplar point. This value determines to which bucket the
        /// exemplar belongs.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }

        /// <summary>Field number for the "timestamp" field.</summary>
        public const int TimestampFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
        /// <summary>
        /// The observation (sampling) time of the above value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
          get { return timestamp_; }
          set {
            timestamp_ = value;
          }
        }

        /// <summary>Field number for the "attachments" field.</summary>
        public const int AttachmentsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Any> _repeated_attachments_codec
            = pb::FieldCodec.ForMessage(26, global::Google.Protobuf.WellKnownTypes.Any.Parser);
        private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> attachments_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any>();
        /// <summary>
        /// Contextual information about the example value. Examples are:
        ///
        ///   Trace: type.googleapis.com/google.monitoring.v3.SpanContext
        ///
        ///   Literal string: type.googleapis.com/google.protobuf.StringValue
        ///
        ///   Labels dropped during aggregation:
        ///     type.googleapis.com/google.monitoring.v3.DroppedLabels
        ///
        /// There may be only a single attachment of any given message type in a
        /// single exemplar, and this is enforced by the system.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> Attachments {
          get { return attachments_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Exemplar);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Exemplar other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Value, other.Value)) return false;
          if (!object.Equals(Timestamp, other.Timestamp)) return false;
          if(!attachments_.Equals(other.attachments_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Value != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Value);
          if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
          hash ^= attachments_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Value != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Value);
          }
          if (timestamp_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Timestamp);
          }
          attachments_.WriteTo(output, _repeated_attachments_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Value != 0D) {
            size += 1 + 8;
          }
          if (timestamp_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
          }
          size += attachments_.CalculateSize(_repeated_attachments_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Exemplar other) {
          if (other == null) {
            return;
          }
          if (other.Value != 0D) {
            Value = other.Value;
          }
          if (other.timestamp_ != null) {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            Timestamp.MergeFrom(other.Timestamp);
          }
          attachments_.Add(other.attachments_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                Value = input.ReadDouble();
                break;
              }
              case 18: {
                if (timestamp_ == null) {
                  Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(Timestamp);
                break;
              }
              case 26: {
                attachments_.AddEntriesFrom(input, _repeated_attachments_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
